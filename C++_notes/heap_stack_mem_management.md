# 堆栈以及内存管理

## C++的代码存储

每个对象所占用的存储空间只是该对象的数据部分（虚函数指针和虚基类指针也属于数据部分）所占用的存储空间，而不包括函数代码所占用的存储空间。

* C++程序的内存格局通常分为四个区：

  * 全局数据区(data area): 全局数据区存放全局变量，静态数据和常量；
  * 代码区(code area)， 所有类成员函数和非成员函数代码存放在代码区
  * 栈区(stack area)，
  * 堆区(heap area)(即自由存储区)。
为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。

- [ ] 根据这个解释，我们可以得知在类的定义时，类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。

## Stack(栈)

是在某块作用域上的内存空间，函数所使用的局部变量等等
全部来自于栈，离开作用域之后自动死亡。

- [ ] 栈对象：又称自动对象，离开作用域之后会被自动清理
- [ ] *static* 关键字修饰的Stack对象：在作用域结束之后仍然继续存
      在，直到程序结束才会结束。

## Heap(堆)

是由操作系统分配的一块全局层面的内存空间，程序可以拿来动态分配

- [ ] 一个例子：

```C++
class Copmlex;

{
    Complex* p = new Complex(1,2);
}
```

在上述的括号结束之后，指针p已经死亡，但是申请的空间（memory)还在，
造成了内存泄漏

## new&delete

* `array new + array delete`: new char[] + delete[] p;

* delete 和同类型的 new搭配使用

* new 实际上分为三步：
  * malloc申请空间
  * 指针类型转换
  * 调用构造函数

* delete分为2步：
  * 析构
  * 回收空间
